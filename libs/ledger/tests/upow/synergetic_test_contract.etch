@problem
function dagState() : Array< Buffer >
  var dag     = DAG();
  var nodes   = dag.getNodes();
  var N       = lengthOf(nodes);
  var problem = Array< Buffer >(N);

  for(i in 0: N-1) 
    if(!nodes[i].has("key"))
      continue;
    endif
    var key = nodes[i].getBuffer("key");
    problem[i] = key;
  endfor

  return problem;
endfunction

@objective
function proofOfWork(problem : Array< Buffer >, solution : Int32 ) : Float64 
  if( solution >= 0)
    var hasher = SHA256();
    hasher.update(problem[solution]);    
    var number = BigUInt( hasher.final() );
    var value = toFloat64(number.toInt32());

    return value;
  endif

  return 1e300;
endfunction

@clear
function applyWork(problem : Array< Buffer >, solution : Int32)
  var x: String = null;
  if( solution >= 0)
    var hasher = SHA256();
    hasher.update(problem[solution]);

    var number = BigUInt( hasher.final() );
    var value = toFloat64(number.toInt32());

  endif
endfunction

@work
@brief("Finds the key in the DAG that minimise the hash value for a nonce.")
@parameters(
    problem = "The problem definition",
    nonce   = "A nonce that initialises the search path"
)
@returns("Solution to the problem given a nonce.")
function mineWork(problem : Array< Buffer >, nonce : BigUInt) :  Int32
  var solution = -1;
  var N = lengthOf(problem);

  if( N == 0)
    return solution;
  endif

  var i = nonce.toInt32();
  if(i < 0)
    i = -i;
  endif
  i = i % N;

  return i;
endfunction

@test_dag_generator
function makeDAGnode(epoch : Int32, entropy : BigUInt) : DAGNode
  var ret = DAGNode();

  ret.set("key", entropy.toBuffer());  

  return ret;
endfunction
