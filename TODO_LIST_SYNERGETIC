- (v) Refactor VM output
- (v) Extend print
- (v) Make it possible to create DAG node 'toDAGNode( type )'
- (v) Implement DAG->SetNodeReferences( node );
- (v) Implement Extract Segment
- (v) Verify signature of DAGNode
- (v) Implement fetch contract into the synergetic execution
- (v) Validate DAG hashes in BlockCoordinator::OnPreExecBlockValidation
    - (v) Traverse back to last known nodes
    - (v) Test for bad blocks
- (v) Finish Synergetic Executor
    - (v) Deserialise block
    - (v) Pass StorageInterface to executor
    - (v) Fetch smart contract source
    - (v) Workout how to attach the state thingie to the contract
- (v) Check that block number is set correctly
- (v) Add state adapters
- (v) Store the contract in the database
- (v) Add Array serialisation
- (v) Extract correct DAG portion for miner, i.e., miner needs to be chain aware
    - (v) Make DAG"Adapter"
    - (v) Make it possible to set block number
- (v) Make check that the extracted data is correct for validation.
- (v) Rewrite test contract
    - (v) Implement SHA256
    - (v) Implement BigNumber
    - (v) Add id to data elements [implement getString]
    - (v) Update contract to simpliest possible search
    - (v) Update nonce to ByteArray
    - (v) Update entropy to ByteArray
- (v) Fix any problems in the test.
- (v) Engrave public key into nonce        
- (v) Test with real data.
- ( ) Tidy test up

- ( ) Sort things out in cpp files
- ( ) Make contract signature validator

- ( ) Tidy code up
- ( ) Add revert test 

- ( ) Move implementation to block coordinator
    - ( ) Create disable functionality

- ( ) Write tests for:
    - ( ) Move contract mockup to tests
    - ( ) DAG syncronisation
    - ( ) DAG Segment extraction
          - ( ) Check size
          - ( ) Check order
    - ( ) SyncronisationExecutor
          - (v) PrepareWorkQueue
          - (v) ValidateWorkAndUpdateState
    - (v) SynergeticMiner
- ( ) Make it possible to extract multiple block segments
- ( ) Streams to implement:
	- ( ) Block generation
	- ( ) Block validation
	- ( ) Roll back
- ( ) Make DAG Service a State machine
- ( ) Change DAG
    - ( ) Follow the design pattern of a state machine for the RPC protocol
    - (v) Simplify and improve tips
- ( ) Fix tips selection
- ( ) Implement Revert
- ( ) Add nonce to script -> Change entropy to ByteArray
- ( ) Make the ability to read the state, but not to write to it 
      in all synergetic contracts, but ClearContest

Notepad:
========

    Identifier contract_id;
    if (!contract_id.Parse(tx.contract_name()))
    {
      return Status::CONTRACT_NAME_PARSE_FAILURE;
    }

    // create the resource address for the contract
    auto const resource = SmartContractManager::CreateAddressForContract(contract_id);

    // query the contents of the address
    auto const result = storage.Get(resource);

    if (!result.failed)
    {
      ConstByteArray contract_source;

      // deserialise the contract source
      serializers::ByteArrayBuffer adapter{result.document};
      adapter >> contract_source;

      // attempt to construct the smart contract in question
      contract = std::make_shared<SmartContract>(std::string{contract_source});
    }

from executor.cpp
    Identifier contract;
    if (!contract.Parse(tx.contract_name()))
    {
      return Status::CONTRACT_NAME_PARSE_FAILURE;
    }

    Contract::Status result{Contract::Status::FAILED};
    {
      // create the cache and state sentinel (lock and unlock resources as well as sandbox)
      CachedStorageAdapter storage_cache{*resources_};
      StateSentinelAdapter storage_adapter{storage_cache, contract.GetParent(), tx.resources(),
                                           tx.raw_resources()};

      // lookup or create the instance of the contract as is needed
      auto chain_code = chain_code_cache_.Lookup(contract.GetParent(), *resources_);
      if (!chain_code)
      {
        FETCH_LOG_WARN(LOGGING_NAME, "Chain code lookup failure!");
        return Status::CHAIN_CODE_LOOKUP_FAILURE;
      }

      // attach the chain code to the current working context
      chain_code->Attach(storage_adapter);

      // Dispatch the transaction to the contract
      FETCH_LOG_DEBUG(LOGGING_NAME, "Dispatch: ", contract.name());
      result = chain_code->DispatchTransaction(contract.name(), tx);

      // detach the chain code from the current context
      chain_code->Detach();

      // force the flushing of the cache *** only if the contract was successful ***
      if (result == Contract::Status::OK)
      {
        storage_cache.Flush();
      }
    }

through chain_code_cache:
from factory.cpp
  if (Identifier::Type::SMART_CONTRACT == contract_id.type())
  {
    // create the resource address for the contract
    auto const resource = SmartContractManager::CreateAddressForContract(contract_id);

    // query the contents of the address
    auto const result = storage.Get(resource);

    if (!result.failed)
    {
      ConstByteArray contract_source;

      // deserialise the contract source
      serializers::ByteArrayBuffer adapter{result.document};
      adapter >> contract_source;

      // attempt to construct the smart contract in question
      contract = std::make_shared<SmartContract>(std::string{contract_source});
    }
  }


from execution_manager.cpp:
      Identifier contract_id;
      if (!contract_id.Parse(tx.contract_name))
      {
        return false;
      }

      for (auto const &resource : tx.resources)
      {
        item->AddLane(
            StateAdapter::CreateAddress(contract_id, resource).lane(block.log2_num_lanes));
      }

from factor.cpp:
  if (Identifier::Type::SMART_CONTRACT == contract_id.type()) {
    // create the resource address for the contract
    auto const resource = SmartContractManager::CreateAddressForContract(contract_id);

    // query the contents of the address
    auto const result = storage.Get(resource);
  }