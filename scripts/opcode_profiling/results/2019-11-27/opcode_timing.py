#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import csv
import subprocess
import numpy as np
from glob import glob
from shutil import copy
from datetime import date

# csv files to be generated by vm_benchmarks
vm_benchmark_path = '../../cmake-build-release/libs/vm-modules/benchmark/'
vm_benchmark_file = 'vm_benchmark.csv'
opcode_list_file = 'opcode_lists.csv'
output_path = 'results/' + date.today().strftime("%Y-%m-%d") + '/'

# number of benchmark repetitions
run_benchmarks = False
make_plots = True
make_tables = True
save_results = True
save_figures = True
n_reps = 100
max_fit_lens = {'Array': 6000, 'FromStr': 100000}
imgformat = 'png'

# selectively suppress benchmarks by setting environment variables
os.environ['FETCH_VM_BENCHMARK_NO_BASIC'] = '1'
os.environ['FETCH_VM_BENCHMARK_NO_OBJECT'] = '1'
os.environ['FETCH_VM_BENCHMARK_NO_PRIM_OPS'] = '1'
os.environ['FETCH_VM_BENCHMARK_NO_MATH'] = '1'
os.environ['FETCH_VM_BENCHMARK_NO_ARRAY'] = '1'
#os.environ['FETCH_VM_BENCHMARK_NO_TENSOR'] = '1'
#os.environ['FETCH_VM_BENCHMARK_NO_CRYPTO'] = '1'


# return index of benchmark from name listed in vm_benchmark_file
def index(row):
    return int(row[0].split('_')[0].split('/')[1])


# get the list of opcodes that are in ops but not in base_ops
def get_net_opcodes(ops, base_ops):
    base_copy = base_ops.copy()
    return [x for x in ops if x not in base_copy or base_copy.remove(x)]


def linear_fit(bms, bm_type, max_len=1e20):

    x = np.array([bm['param_val']
                  for bm in bms.values() if bm['type'] == bm_type])

    y = np.array([bm['net_mean']
                  for bm in bms.values() if bm['type'] == bm_type])
    y0 = y[0]

    # anchor least-squares fit to base (length = 1) result
    y = y - y0

    # fit only to specified range (if given) because some bms become nonlinear for large values
    x = x[np.where(x < max_len)] - 1
    y = y[0:len(x)]

    A = np.reshape(x, (len(x), 1))
    m, = np.linalg.lstsq(A, y, rcond=None)[0]

    return [m, y0-m]
    # return np.polyfit(np.array(x, dtype=float), np.array(y), 1).tolist()


def aggregate_stats(bms, bm_type, base_inds):

    inds = [ind for (ind, bm) in bms.items() if bm['type'] == bm_type]
    n_type = len(inds)
    all_cpu_times = np.hstack(
        [np.array(bms[ind]['cpu_times']) for ind in inds])
    base_ind = base_inds[inds[0]]
    agg_mean = np.mean(all_cpu_times)
    agg_median = np.median(all_cpu_times)
    agg_stddev = np.std(all_cpu_times)
    agg_net_mean = agg_mean - bms[base_ind]['mean']
    agg_net_median = agg_median - bms[base_ind]['median']
    agg_net_stderr = np.sqrt((agg_stddev ** 2) / (n_reps*n_type) +
                             (bms[base_ind]['stddev'] ** 2) / n_reps) ** 0.5
    return agg_net_mean, agg_net_median, agg_net_stderr


# delete old file if it exists
if run_benchmarks and os.path.exists(opcode_list_file):
    os.remove(opcode_list_file)

# run benchmarks
if run_benchmarks:
    stdout = subprocess.call([vm_benchmark_path + 'vm-benchmarks',
                              '--benchmark_out=' + vm_benchmark_file,
                              '--benchmark_out_format=csv',
                              '--benchmark_repetitions=' + str(n_reps),
                              '--benchmark_report_aggregates_only=false',
                              '--benchmark_display_aggregates_only=false'])

# read opcode lists and baseline bms
with open(opcode_list_file) as csvfile:
    csvreader = csv.reader(csvfile)
    opcode_rows = [row for row in csvreader]

# create dicts from benchmark indices to names, baseline indices, and opcode lists
bm_names = {int(row[0]): row[1] for row in opcode_rows}
bm_inds = {row[1]: int(row[0]) for row in opcode_rows}
baseline_inds = {bm_inds[row[1]]: bm_inds[row[2]] for row in opcode_rows}
opcodes = {int(row[0]): [int(op) for (i, op) in enumerate(row[3:])]
           for row in opcode_rows}

# read results in text format
with open(vm_benchmark_file) as csvfile:
    csvreader = csv.reader(csvfile)
    bm_rows = [row for row in csvreader if 'Benchmark' in row[0]]

data_rows = [row for row in bm_rows if '_' not in row[0]]
cpu_times = {ind: [float(row[2]) for row in data_rows if int(row[0].split('/')[1]) == ind]
             for ind in bm_inds.values()}

# get cpu time stats (in ns) for each bm index
means = {index(row): float(row[3]) for row in bm_rows if 'mean' in row[0]}
medians = {index(row): float(row[3]) for row in bm_rows if 'median' in row[0]}
stddevs = {index(row): float(row[3]) for row in bm_rows if 'stddev' in row[0]}

bm_classes = ['Basic', 'String', 'Prim', 'Math', 'Array', 'Tensor', 'Sha256']
prim_bm_classes = ['Prim', 'Math']
param_bm_classes = ['String', 'Array', 'Sha256']

# collect benchmark data and stats
benchmarks = {ind: {'name': name,
                    'mean': means[ind],
                    'median': medians[ind],
                    'stddev': stddevs[ind],
                    'baseline': bm_names[baseline_inds[ind]],
                    'opcodes': opcodes[ind],
                    'net_mean': means[ind] - means[baseline_inds[ind]],
                    'net_median': medians[ind] - medians[baseline_inds[ind]],
                    'net_stderr': (stddevs[ind] ** 2 + stddevs[baseline_inds[ind]] ** 2) ** 0.5 / n_reps ** 0.5,
                    'net_opcodes': get_net_opcodes(opcodes[ind], opcodes[baseline_inds[ind]]),
                    'ext_opcodes': get_net_opcodes(opcodes[baseline_inds[ind]], opcodes[ind]),
                    'cpu_times': cpu_times[ind],
                    'type': ''
                    } for (ind, name) in bm_names.items()}

for (ind, bm) in benchmarks.items():
    bm_class = [cl for cl in bm_classes if cl in bm['name']]
    if len(bm_class) == 0:
        bm['class'] = 'Basic'
    else:
        bm['class'] = bm_class[0]
    if bm['class'] == 'Tensor':
        bm['type'] = bm['name'].split('-')[0]
        dim_size = bm['name'].split('_')[1]
        bm['dim'] = int(dim_size.split('-')[0])
        bm['param_val'] = int(dim_size.split('-')[1])**bm['dim']
    elif bm['class'] in param_bm_classes and '_' in bm['name']:
        bm['type'] = bm['name'].split('_')[0]
        bm['param_val'] = int(bm['name'].split('_')[1])

# collect tensor benchmark data
tensor_bm_types = {bm['type']
                   for bm in benchmarks.values() if bm['class'] == 'Tensor'}

# collect parameterized benchmark data
param_bm_types = {bm['type'] for bm in benchmarks.values(
) if bm['class'] in param_bm_classes and '_' in bm['name']}
param_bm_types = param_bm_types.union(tensor_bm_types)

param_bms = {type_name: {'inds': [ind for (ind, bm) in benchmarks.items() if bm['type'] == type_name]}
             for type_name in param_bm_types}

for (bm_type, param_bm) in param_bms.items():
    ind0 = param_bm['inds'][0]
    agg_stats = aggregate_stats(benchmarks, bm_type, baseline_inds)
    param_bm['opcodes'] = benchmarks[ind0]['opcodes']
    param_bm['baseline'] = benchmarks[ind0]['baseline']
    param_bm['net_opcodes'] = benchmarks[ind0]['net_opcodes']
    param_bm['param_vals'] = [benchmarks[i]['param_val']
                              for i in param_bm['inds']]
    param_bm['net_means'] = [benchmarks[ind]['net_mean']
                             for ind in param_bm['inds']]
    param_bm['net_medians'] = [benchmarks[ind]['net_median']
                               for ind in param_bm['inds']]
    param_bm['net_stderrs'] = [benchmarks[ind]['net_stderr']
                               for ind in param_bm['inds']]
    param_bm['agg_net_mean'] = agg_stats[0]
    param_bm['agg_net_median'] = agg_stats[1]
    param_bm['agg_net_stderr'] = agg_stats[2]
    max_len = 1e20
    for key in max_fit_lens:
        if key in benchmarks[ind0]['name']:
            max_len = max_fit_lens[key]
    param_bm['lfit'] = linear_fit(benchmarks, bm_type, max_len)

if save_results:

    if not os.path.exists('results'):
        os.mkdir('results')

    if not os.path.exists(output_path):
        os.mkdir(output_path)
        os.mkdir(output_path + 'plots/')

    # copy output of benchmark runs
    copy(vm_benchmark_file, output_path + vm_benchmark_file)
    copy(opcode_list_file, output_path + opcode_list_file)

    # copy source code
    for file in glob(r'*.py'):
        copy(file, output_path)

if make_tables:

    from vm_benchmark_tables import benchmark_table, primitive_table, linear_fit_table

    for bm_cls in bm_classes:
        benchmark_table(benchmarks, n_reps, bm_cls)

    for bm_cls in prim_bm_classes:
        primitive_table(benchmarks, n_reps, bm_cls)

    for bm_cls in param_bm_classes:
        linear_fit_table(param_bms, n_reps, bm_cls)

if make_plots:

    from vm_benchmark_plots import plot_linear_fit

    fig = 0
    for (name, param_bm) in param_bms.items():
        plot_linear_fit(name, param_bm, fig=fig, savefig=save_figures,
                        savepath=output_path+'plots/', imgformat=imgformat)
        fig += 1

#del benchmarks[9]
#del benchmarks[10]


def least_squares_opcode_times(benchmarks, optimes, bm_cls={'Basic'}, prim_type=''):

    basic_bms = [bm for (ind, bm) in benchmarks.items()
                 if bm['class'] in bm_cls and prim_type in bm['name']]

    basic_ops = set()
    for bm in basic_bms:
        basic_ops = basic_ops.union(set(bm['opcodes']))

    if optimes != None:
        known_ops = set(optimes.keys()).intersection(basic_ops)
    else:
        known_ops = set()
    new_ops = basic_ops - known_ops

    known_ops = np.array(list(known_ops))
    xk = np.array([optimes[op] for op in known_ops])
    new_ops = np.array(list(new_ops))

    ops = np.hstack((known_ops, new_ops))

    kop2ind = {op: ind for (ind, op) in enumerate(known_ops)}
    nop2ind = {op: ind for (ind, op) in enumerate(new_ops)}

    A = np.zeros((n_reps*len(basic_bms), len(new_ops)))
    Ak = np.zeros((n_reps*len(basic_bms), len(known_ops)))
    b = np.zeros(n_reps*len(basic_bms))
    for (ind, bm) in enumerate(basic_bms):
        for rep in range(0, n_reps):
            i = ind*n_reps + rep
            for op in bm['opcodes']:
                b[i] = bm['cpu_times'][rep]  # /bm['stddev']
                if op in known_ops:
                    j = kop2ind[op]
                    Ak[i, j] += 1
                else:
                    j = nop2ind[op]
                    A[i, j] += 1  # /bm['stddev']


#    Abar =
#    for (i, op) in enumerate(basic_ops):

    if len(Ak) > 0:
        b = b - Ak@xk

    x = np.linalg.lstsq(A, b, rcond=None)[0]

    newtimes = {op: x[i] for (i, op) in enumerate(new_ops)}
    if optimes == None:
        optimes = newtimes
    else:
        optimes = optimes.update(newtimes)

    print(np.vstack((new_ops, x)).T)

    print([bm['name'] for bm in basic_bms])

    print(A@x-b)

    return optimes, A, b


optimes = dict()
benchmark_table(benchmarks, n_reps, 'Basic')
primitive_table(benchmarks, n_reps, 'Prim')
optimes, A, b = least_squares_opcode_times(benchmarks, optimes)
optimes, A, b = least_squares_opcode_times(
    benchmarks, optimes, bm_cls={'Prim'}, prim_type='UInt16')


#[bm['net_mean'] for bm in basic_bms]
