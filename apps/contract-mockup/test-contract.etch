@problem
function createProblem() : Matrix< Float64 >
  PrintLn("Generating problem");

  // Getting data from DAG
  var dag = DAG();
  var nodes = dag.getNodes();
  var N = lengthOf(nodes);

  // Generating problem
  var problem = Matrix< Float64 >(N,N) ;

  Print("Nodes contain ");
  Print(N);
  PrintLn(" elements");

  for(i in 0: N-1) 
    Print("Element ");
    PrintLn(i);
    PrintLn(nodes[i].owner());
  endfor

  return problem;
endfunction

@objective
function evaluate(problem : Matrix< Float64 >, solution : Array< Int64 >) : Float64
  var cost : Float64 = toFloat64(0);

  return cost;
endfunction

@clear
function sellItems(problem : Matrix< Float64 >, solution : Array< Int64 >)

endfunction

@work
function leisureMarketWork(problem : Matrix< Float64 >, nonce : Int64) : Array< Int64 >
  PrintLn("Mining solution.");

  // Algorithm parameters  
  var beta0 : Float64 = 0.1;
  var beta1 : Float64 = 3.;
  var beta  : Float64 = beta0;
  var run_time : Int64 = toInt64(1000);

  // Getting the problem
  var n = 64; // Problem size.
  var state = Array< Int64 >(n);
  // TODO: Load
  var cost_function = evaluate(problem, state);

  // Main loop of annealing algorithm
  var delta = (beta1 - beta0) / toFloat64(run_time);
  var rng = CryptoRNG( toUInt64(nonce) );
  
  for(i in toInt64(0):run_time)
    for(j in 0:n-1)

      if(state[j] == toInt64(0))
        state[j] = toInt64(1);
      else
        state[j] = toInt64(0);
      endif

      var new_cost = evaluate(problem, state);
      var cost_change = cost_function - new_cost;
      var boltzmann = exp(-beta * cost_change);

      if( boltzmann < rng.nextAsFloat())

      endif
    endfor

    beta += delta;
  endfor

  return Array< Int64 >(0);
endfunction


function main()
//  leisureMarketWork(toInt64(2042223));

  var bytearray = ByteArray(20);
  for(i in 0:19)
    bytearray[i] = toByte(64 + i);
  endfor
  PrintLn(bytearray);


  var messages = Array< ByteArray >(3);
  messages[0] = bytearray.copy();
  messages[1] = bytearray.copy();
  messages[2] = bytearray.copy();

  messages[0][0] = toByte(97);
  messages[1][0] = toByte(98);
  messages[2][0] = toByte(99);

  PrintLn(messages[0]);
  PrintLn(messages[1]); 
  PrintLn(messages[2]); 
endfunction


/*
@settle("syngergic_contract1")
function applyWork(work: Array< Int64 >) : Float64
  // Computes the market optimality

  return 0.;
endfunction

@bid("syngergic_contract1")
function addBid()

endfunction

@objective("syngergic_contract1")
function leisureMarketObjective(work: Array< Int64 >) : Float64
  var x = true;

  return 0.;
endfunction

@price("syngergic_contract1")
@param(work_param = "Work to be evaluated.")
function workPrice(work: Array< Int64 > )
  // Computes the price of the work
endfunction
*/