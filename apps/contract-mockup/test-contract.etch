@problem
function smartMarketProblemDefinition() : Array< Float64 >
  // Getting data from DAG
  var dag = DAG();
  var nodes = dag.getNodes();
  var N = lengthOf(nodes);

  // Generating problem
  var item_count = 0;
  var bid_count = 0;

  for(i in 0: N-1) 
    var type = nodes[i].getInt32("type");
    if(type == 2)
      item_count += 1;
    else
      bid_count += 1;
    endif
  endfor

  // Sorting elements according to type
  var items = Array< Float64 >(item_count);
  var bids = Array< DAGNode >(bid_count);  

  for(i in 0: N-1) 
    var type = nodes[i].getInt32("type");  
    var id = nodes[i].getInt32("id");
    if(type == 2)    
      items[id] = nodes[i].getNumber("price");
    else
      bids[id] = nodes[i];
    endif
  endfor

  // Building problem
  var problem = Array< Float64 >(bid_count * bid_count);

  for(i in 0:(lengthOf(problem) - 1))
    problem[i] = toFloat64(0);
  endfor

  for(i in 0:(bid_count - 1))
    var bid = bids[i];
    var bidding_on = bid.getArrayInt32("bid_on");

    // Setting the value extract  
    var sum_min_selling_price = toFloat64(0);

    for(j in 0:(lengthOf(bidding_on)-1))
      var bidid = bidding_on[j];
      sum_min_selling_price += items[bidid];
    endfor
  
    problem[i * bid_count + i] = -(bid.getNumber("price") - sum_min_selling_price);

    // Marking incompatible bids
    var excludes = bid.getArrayInt32("excludes");
    for(k in 0:lengthOf(excludes)-1)
      var j = excludes[k];
      problem[i * bid_count + j] = toFloat64(100.); // TODO: Something better
      problem[j * bid_count + i] = toFloat64(100.); // TODO: Something better      
    endfor
  endfor

  return problem;
endfunction

@objective
function computeExtractedValue(problem : Array< Float64 >, solution : Array< Int32 >) : Float64
  var cost : Float64 = toFloat64(0);
  var N = lengthOf(solution);

  for(i in 0:N-1)
    var s1 = toFloat64(solution[i]);
    cost += s1 * problem[i*N + i];
    for(j in 0:i-1)
      var s2 = toFloat64(solution[j]);
      cost += s1 * s2 * problem[i*N + j];
    endfor

  endfor

  return cost;
endfunction

@clear
function clearMarketPool(problem : Array< Float64 >, state : Array< Int32 >)
  Print("Cost = ");
  PrintLn( computeExtractedValue(problem, state) );
  for(j in 0:lengthOf(state)-1)
    Print(state[j]);
    Print(", ");
  endfor
  PrintLn("");
endfunction

@work
function proposeMarketConfiguration(problem : Array< Float64 >, nonce : Int64) : Array< Int32 >
  // Computing problem size
  var N = toInt32(sqrt(toFloat64(lengthOf(problem))));

  // Instantiating random generator
  var rng = CryptoRNG( toUInt64(nonce) );
  
  // Algorithm parameters  
  var beta0 : Float64 = 0.1;
  var beta1 : Float64 = 3.;
  var beta  : Float64 = beta0;
  var run_time : Int64 = toInt64(1000);

  // Getting the problem
  var state = Array< Int32 >(N);
  for(i in 0:N-1)
    var value = toInt32(and( leftShift(rng.next(), toUInt64(17)) ,  toUInt64(1)));
    state[i] = value;
  endfor

  var extractedValue = computeExtractedValue(problem, state);

  // Main loop of annealing algorithm
  var delta = (beta1 - beta0) / toFloat64(run_time);
  
  for(i in toInt64(0):run_time)
    for(j in 0:N-1)

      if(state[j] == 0)
        state[j] = 1;
      else
        state[j] = 0;
      endif

      var newExtractedValue = computeExtractedValue(problem, state);
      // Negative values means gain here since we contracts minimise
      // the objective.
      var valueGain = extractedValue - newExtractedValue;
      var boltzmann = exp(-beta * valueGain);

      if( boltzmann < rng.nextAsFloat())
        // We accpt the move
        extractedValue = newExtractedValue;
      else
        // And otherwise reject it.
        if(state[j] == 0)
          state[j] = 1;
        else
          state[j] = 0;
        endif      
      endif
    endfor

    beta += delta;
  endfor

  return state;
endfunction

