<?xml version='1.0' encoding='utf-8'?>
<namespace id="fetch::service" name="service" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <functiontemplate id="fetch::service::PackArgs" name="PackArgs">
    <brief> Function that packs arguments to serializer.</brief>
    <doc>Serializers for all arguments in the argument list are requried.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::service::PackArgs::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::service#fetch::service::serializer_type" />
    </argument>
    <argument id="fetch::service::PackArgs::args" name="args">
      <doc>are the arguments to the function.</doc>
      <type name="arguments..." />
    </argument>
    <templatetypeparameter id="fetch::service::PackArgs::arguments" name="arguments" />
  </functiontemplate>
  <functiontemplate id="fetch::service::PackCall" name="PackCall">
    <brief> This function packs a function call into byte array.</brief>
    <doc>For this function to work, it is a requirement that there exists a
serilization implementation for all argument types in the argument
list.

The serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::service::PackCall::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::service#fetch::service::serializer_type" />
    </argument>
    <argument id="fetch::service::PackCall::protocol" name="protocol">
      <doc>is the protocol the call belongs to.</doc>
      <type name="protocol_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::protocol_handler_type" />
    </argument>
    <argument id="fetch::service::PackCall::function" name="function">
      <doc>is the function that is being called.</doc>
      <type name="function_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::function_handler_type" />
    </argument>
    <argument id="fetch::service::PackCall::args" name="args">
      <doc>are the arguments to the function.</doc>
      <type name="arguments..." />
    </argument>
    <templatetypeparameter id="fetch::service::PackCall::arguments" name="arguments">
      <brief>are the argument types of args.</brief>
    </templatetypeparameter>
  </functiontemplate>
  <variable id="fetch::service::SERVICE_ERROR" name="SERVICE_ERROR">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <variable id="fetch::service::SERVICE_FEED" name="SERVICE_FEED">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <variable id="fetch::service::SERVICE_FUNCTION_CALL" name="SERVICE_FUNCTION_CALL">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <variable id="fetch::service::SERVICE_RESULT" name="SERVICE_RESULT">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <variable id="fetch::service::SERVICE_SUBSCRIBE" name="SERVICE_SUBSCRIBE">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <variable id="fetch::service::SERVICE_UNSUBSCRIBE" name="SERVICE_UNSUBSCRIBE">
    <type name="service_classification_type" qualifier=" const" ref="fetch::service#fetch::service::service_classification_type" />
  </variable>
  <namespace name="details" ref="fetch::service::details#fetch::service::details" />
  <namespace name="error" ref="fetch::service::error#fetch::service::error" />
  <class name="AbstractCallable" ref="fetch::service::AbstractCallable#fetch::service::AbstractCallable">
    <brief> Abstract class for callables.</brief>
  </class>
  <class name="AbstractPublicationFeed" ref="fetch::service::AbstractPublicationFeed#fetch::service::AbstractPublicationFeed">
    <brief> Super class for publishers.</brief>
  </class>
  <classtemplate name="CallableClassMember" ref="fetch::service::CallableClassMember#fetch::service::CallableClassMember">
    <brief> A member function wrapper that takes a serialized input.</brief>
    <templatetypeparameter id="fetch::service::CallableClassMember::C" name="C">
      <brief>is the class type to which the member function belongs.</brief>
    </templatetypeparameter>
    <templatetypeparameter id="fetch::service::CallableClassMember::F" name="F">
      <brief>is the function signature.</brief>
    </templatetypeparameter>
  </classtemplate>
  <class name="FeedSubscriptionManager" ref="fetch::service::FeedSubscriptionManager#fetch::service::FeedSubscriptionManager">
    <brief> This is a subscription manager that is used on the server side.</brief>
  </class>
  <classtemplate name="Function" ref="fetch::service::Function#fetch::service::Function">
    <brief> A function wrapper that takes a serialized input.</brief>
    <templatetypeparameter id="fetch::service::Function::F" name="F">
      <brief>is the function signature.</brief>
    </templatetypeparameter>
  </classtemplate>
  <class name="Function" ref="fetch::service::Function#fetch::service::Function">
    <brief>No function args, void return</brief>
  </class>
  <class name="HasPublicationFeed" ref="fetch::service::HasPublicationFeed#fetch::service::HasPublicationFeed">
    <brief> Publication functionality for a single feed.</brief>
  </class>
  <class name="Promise" ref="fetch::service::Promise#fetch::service::Promise" />
  <class name="Protocol" ref="fetch::service::Protocol#fetch::service::Protocol">
    <brief> A class that defines a generic protocol.</brief>
  </class>
  <classtemplate name="ServiceClient" ref="fetch::service::ServiceClient#fetch::service::ServiceClient">
    <templatetypeparameter id="fetch::service::ServiceClient::T" name="T" />
  </classtemplate>
  <class name="ServiceClientInterface" ref="fetch::service::ServiceClientInterface#fetch::service::ServiceClientInterface" />
  <classtemplate name="ServiceServer" ref="fetch::service::ServiceServer#fetch::service::ServiceServer">
    <templatetypeparameter id="fetch::service::ServiceServer::T" name="T" />
  </classtemplate>
  <class name="ServiceServerInterface" ref="fetch::service::ServiceServerInterface#fetch::service::ServiceServerInterface" />
  <enum anonymous="yes" id="fetch::service::Callable" name="Callable">
    <enumvalue id="fetch::service::CLIENT_ID_ARG" name="CLIENT_ID_ARG" value="1" />
  </enum>
  <typedef id="fetch::service::feed_handler_type" name="feed_handler_type">
    <type name="uint8_t" />
  </typedef>
  <typedef id="fetch::service::function_handler_type" name="function_handler_type">
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::service::protocol_handler_type" name="protocol_handler_type">
    <brief>typedef serializers::ByteArrayBuffer serializer_type;</brief>
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::service::serializer_type" name="serializer_type">
    <type name="serializers::TypedByte_ArrayBuffer" />
  </typedef>
  <typedef id="fetch::service::service_classification_type" name="service_classification_type">
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::service::subscription_handler_type" name="subscription_handler_type">
    <type name="uint8_t" />
  </typedef>
  <function id="fetch::service::PackArgs" name="PackArgs">
    <brief> This is the no-argument packer.</brief>
    <doc>This function covers the case where no arguments are given. The
serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::service::PackArgs::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::service#fetch::service::serializer_type" />
    </argument>
  </function>
  <function id="fetch::service::PackCall" name="PackCall">
    <brief> This function is the no-argument packer.</brief>
    <doc>This function covers the case where no arguments are given. The
serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::service::PackCall::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::service#fetch::service::serializer_type" />
    </argument>
    <argument id="fetch::service::PackCall::protocol" name="protocol">
      <doc>is the protocol the call belongs to.</doc>
      <type name="protocol_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::protocol_handler_type" />
    </argument>
    <argument id="fetch::service::PackCall::function" name="function">
      <doc>is the function that is being called.</doc>
      <type name="function_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::function_handler_type" />
    </argument>
  </function>
  <function id="fetch::service::PackCallWithPackedArguments" name="PackCallWithPackedArguments">
    <brief> This function packs a function call using packed arguments.</brief>
    <doc>This function can be used to pack aguments with out the need of
vadariac arguments.

The serializer is left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::service::PackCallWithPackedArguments::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::service#fetch::service::serializer_type" />
    </argument>
    <argument id="fetch::service::PackCallWithPackedArguments::protocol" name="protocol">
      <doc>is the protocol the call belongs to.</doc>
      <type name="protocol_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::protocol_handler_type" />
    </argument>
    <argument id="fetch::service::PackCallWithPackedArguments::function" name="function">
      <doc>is the function that is being called.</doc>
      <type name="function_handler_type" qualifier=" const &amp;" ref="fetch::service#fetch::service::function_handler_type" />
    </argument>
    <argument id="fetch::service::PackCallWithPackedArguments::args" name="args">
      <doc>is the packed arguments.</doc>
      <type name="byte_array::ByteArray" qualifier=" const &amp;" />
    </argument>
  </function>
</namespace>
