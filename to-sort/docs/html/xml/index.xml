<?xml version='1.0' encoding='utf-8'?>
<index xmlns="http://jessevdk.github.com/cldoc/1.0">
  <category name="Developers Guide" ref="Developers Guide#Developers Guide">
    <brief>Developers documentation.</brief>
    <category name="Git Practices" ref="Developers Guide::Git Practices#Developers Guide::Git Practices">
      <brief>We describe how we </brief>
    </category>
    <category name="Components that needs to be developed" ref="Developers Guide::Components that needs to be developed#Developers Guide::Components that needs to be developed">
      <brief>A short description of what we need to develop.</brief>
    </category>
    <category name="Understanding the networking framework" ref="Developers Guide::Understanding the networking framework#Developers Guide::Understanding the networking framework">
      <brief># Understanding the RPC framework</brief>
    </category>
    <category name="C++ Style Guide" ref="Developers Guide::C++ Style Guide#Developers Guide::C++ Style Guide">
      <brief>A guide that describes the style of our code.</brief>
    </category>
    <category name="Getting Started" ref="Developers Guide::Getting Started#Developers Guide::Getting Started">
      <brief>The initial steps to get started.</brief>
    </category>
    <category name="Tutorial" ref="Developers Guide::Tutorial#Developers Guide::Tutorial">
      <category name="Creating a peer to peer network" ref="Developers Guide::Tutorial::Creating a peer to peer network#Developers Guide::Tutorial::Creating a peer to peer network">
        <brief>In this tutorial we go through the concepts of RPC, data feed and serialization.</brief>
      </category>
    </category>
  </category>
  <namespace name="fetch" ref="fetch#fetch">
    <namespace name="service" ref="fetch::service#fetch::service">
      <namespace name="details" ref="fetch::service::details#fetch::service::details">
        <structtemplate name="Packer" ref="fetch::service::details::Packer#fetch::service::details::Packer">
          <brief> Argument packing routines for callables.</brief>
          <templatetypeparameter id="fetch::service::details::Packer::T" name="T">
            <brief>is the type of the argument that will be packed next.</brief>
          </templatetypeparameter>
          <templatetypeparameter id="fetch::service::details::Packer::arguments" name="arguments">
            <brief>are the arguments that remains to be pack</brief>
          </templatetypeparameter>
        </structtemplate>
        <class name="PromiseImplementation" ref="fetch::service::details::PromiseImplementation#fetch::service::details::PromiseImplementation" />
      </namespace>
      <namespace name="error" ref="fetch::service::error#fetch::service::error" />
      <class name="AbstractCallable" ref="fetch::service::AbstractCallable#fetch::service::AbstractCallable">
        <brief> Abstract class for callables.</brief>
      </class>
      <class name="AbstractPublicationFeed" ref="fetch::service::AbstractPublicationFeed#fetch::service::AbstractPublicationFeed">
        <brief> Super class for publishers.</brief>
      </class>
      <classtemplate name="CallableClassMember" ref="fetch::service::CallableClassMember#fetch::service::CallableClassMember">
        <brief> A member function wrapper that takes a serialized input.</brief>
        <templatetypeparameter id="fetch::service::CallableClassMember::C" name="C">
          <brief>is the class type to which the member function belongs.</brief>
        </templatetypeparameter>
        <templatetypeparameter id="fetch::service::CallableClassMember::F" name="F">
          <brief>is the function signature.</brief>
        </templatetypeparameter>
      </classtemplate>
      <class name="FeedSubscriptionManager" ref="fetch::service::FeedSubscriptionManager#fetch::service::FeedSubscriptionManager">
        <brief> This is a subscription manager that is used on the server side.</brief>
      </class>
      <classtemplate name="Function" ref="fetch::service::Function#fetch::service::Function">
        <brief> A function wrapper that takes a serialized input.</brief>
        <templatetypeparameter id="fetch::service::Function::F" name="F">
          <brief>is the function signature.</brief>
        </templatetypeparameter>
      </classtemplate>
      <class name="Function" ref="fetch::service::Function#fetch::service::Function">
        <brief>No function args, void return</brief>
      </class>
      <class name="HasPublicationFeed" ref="fetch::service::HasPublicationFeed#fetch::service::HasPublicationFeed">
        <brief> Publication functionality for a single feed.</brief>
      </class>
      <class name="Promise" ref="fetch::service::Promise#fetch::service::Promise" />
      <class name="Protocol" ref="fetch::service::Protocol#fetch::service::Protocol">
        <brief> A class that defines a generic protocol.</brief>
      </class>
      <classtemplate name="ServiceClient" ref="fetch::service::ServiceClient#fetch::service::ServiceClient">
        <templatetypeparameter id="fetch::service::ServiceClient::T" name="T" />
      </classtemplate>
      <class name="ServiceClientInterface" ref="fetch::service::ServiceClientInterface#fetch::service::ServiceClientInterface" />
      <classtemplate name="ServiceServer" ref="fetch::service::ServiceServer#fetch::service::ServiceServer">
        <templatetypeparameter id="fetch::service::ServiceServer::T" name="T" />
        <class name="ClientRPCInterface" ref="fetch::service::ServiceServer::ClientRPCInterface#fetch::service::ServiceServer::ClientRPCInterface">
          <brief>TODO Rename and move</brief>
        </class>
        <struct name="PendingMessage" ref="fetch::service::ServiceServer::PendingMessage#fetch::service::ServiceServer::PendingMessage">
          <brief>EN of ClientRPC</brief>
        </struct>
      </classtemplate>
      <class name="ServiceServerInterface" ref="fetch::service::ServiceServerInterface#fetch::service::ServiceServerInterface" />
    </namespace>
  </namespace>
  <report name="Documentation generator" ref="report" />
</index>
