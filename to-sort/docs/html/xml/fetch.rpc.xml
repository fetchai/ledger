<?xml version='1.0' encoding='utf-8'?>
<namespace id="fetch::rpc" name="rpc" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <functiontemplate id="fetch::rpc::PackArgs" name="PackArgs">
    <brief> Function that packs arguments to serializer.</brief>
    <doc>Serializers for all arguments in the argument list are requried.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::rpc::PackArgs::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::rpc#fetch::rpc::serializer_type" />
    </argument>
    <argument id="fetch::rpc::PackArgs::args" name="args">
      <doc>are the arguments to the function.</doc>
      <type name="arguments..." />
    </argument>
    <templatetypeparameter id="fetch::rpc::PackArgs::arguments" name="arguments" />
  </functiontemplate>
  <functiontemplate id="fetch::rpc::PackCall" name="PackCall">
    <brief> This function packs a function call into byte array.</brief>
    <doc>For this function to work, it is a requirement that there exists a
serilization implementation for all argument types in the argument
list.

The serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::rpc::PackCall::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::rpc#fetch::rpc::serializer_type" />
    </argument>
    <argument id="fetch::rpc::PackCall::protocol" name="protocol">
      <doc>is the protocol the call belongs to.</doc>
      <type name="protocol_handler_type" qualifier=" const &amp;" ref="fetch::rpc#fetch::rpc::protocol_handler_type" />
    </argument>
    <argument id="fetch::rpc::PackCall::function" name="function">
      <doc>is the function that is being called.</doc>
      <type name="function_handler_type" qualifier=" const &amp;" ref="fetch::rpc#fetch::rpc::function_handler_type" />
    </argument>
    <argument id="fetch::rpc::PackCall::args" name="args">
      <doc>are the arguments to the function.</doc>
      <type name="arguments..." />
    </argument>
    <templatetypeparameter id="fetch::rpc::PackCall::arguments" name="arguments">
      <brief>are the argument types of args.</brief>
    </templatetypeparameter>
  </functiontemplate>
  <variable id="fetch::rpc::RPC_ERROR" name="RPC_ERROR">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <variable id="fetch::rpc::RPC_FEED" name="RPC_FEED">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <variable id="fetch::rpc::RPC_FUNCTION_CALL" name="RPC_FUNCTION_CALL">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <variable id="fetch::rpc::RPC_RESULT" name="RPC_RESULT">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <variable id="fetch::rpc::RPC_SUBSCRIBE" name="RPC_SUBSCRIBE">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <variable id="fetch::rpc::RPC_UNSUBSCRIBE" name="RPC_UNSUBSCRIBE">
    <type name="rpc_classification_type" qualifier=" const" ref="fetch::rpc#fetch::rpc::rpc_classification_type" />
  </variable>
  <namespace name="details" ref="fetch::rpc::details#fetch::rpc::details" />
  <namespace name="error" ref="fetch::rpc::error#fetch::rpc::error" />
  <class name="AbstractCallable" ref="fetch::rpc::AbstractCallable#fetch::rpc::AbstractCallable">
    <brief> Abstract class for callables.</brief>
  </class>
  <class name="AbstractPublicationFeed" ref="fetch::rpc::AbstractPublicationFeed#fetch::rpc::AbstractPublicationFeed">
    <brief> Super class for publishers.</brief>
  </class>
  <classtemplate name="CallableClassMember" ref="fetch::rpc::CallableClassMember#fetch::rpc::CallableClassMember">
    <brief> A member function wrapper that takes a serialized input.</brief>
    <templatetypeparameter id="fetch::rpc::CallableClassMember::C" name="C">
      <brief>is the class type to which the member function belongs.</brief>
    </templatetypeparameter>
    <templatetypeparameter id="fetch::rpc::CallableClassMember::F" name="F">
      <brief>is the function signature.</brief>
    </templatetypeparameter>
  </classtemplate>
  <class name="FeedSubscriptionManager" ref="fetch::rpc::FeedSubscriptionManager#fetch::rpc::FeedSubscriptionManager">
    <brief> This is a subscription manager that is used on the server side.</brief>
  </class>
  <classtemplate name="Function" ref="fetch::rpc::Function#fetch::rpc::Function">
    <brief> A function wrapper that takes a serialized input.</brief>
    <templatetypeparameter id="fetch::rpc::Function::F" name="F">
      <brief>is the function signature.</brief>
    </templatetypeparameter>
  </classtemplate>
  <class name="Function" ref="fetch::rpc::Function#fetch::rpc::Function">
    <brief>No function args, void return</brief>
  </class>
  <class name="HasPublicationFeed" ref="fetch::rpc::HasPublicationFeed#fetch::rpc::HasPublicationFeed">
    <brief> Publication functionality for a single feed.</brief>
  </class>
  <class name="Promise" ref="fetch::rpc::Promise#fetch::rpc::Promise" />
  <class name="Protocol" ref="fetch::rpc::Protocol#fetch::rpc::Protocol">
    <brief> A class that defines a generic protocol.</brief>
  </class>
  <class name="ServiceClient" ref="fetch::rpc::ServiceClient#fetch::rpc::ServiceClient" />
  <class name="ServiceServer" ref="fetch::rpc::ServiceServer#fetch::rpc::ServiceServer" />
  <typedef id="fetch::rpc::feed_handler_type" name="feed_handler_type">
    <type name="uint8_t" />
  </typedef>
  <typedef id="fetch::rpc::function_handler_type" name="function_handler_type">
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::rpc::message_queue_type" name="message_queue_type">
    <type name="std::__1::deque&lt;fetch::byte_array::ReferencedByteArray, std::__1::allocator&lt;fetch::byte_array::ReferencedByteArray&gt; &gt;" />
  </typedef>
  <typedef id="fetch::rpc::message_type" name="message_type">
    <type name="byte_array::ReferencedByteArray" />
  </typedef>
  <typedef id="fetch::rpc::protocol_handler_type" name="protocol_handler_type">
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::rpc::rpc_classification_type" name="rpc_classification_type">
    <type name="uint64_t" />
  </typedef>
  <typedef id="fetch::rpc::serializer_type" name="serializer_type">
    <type name="serializers::TypedByte_ArrayBuffer" />
  </typedef>
  <typedef id="fetch::rpc::subscription_handler_type" name="subscription_handler_type">
    <type name="uint8_t" />
  </typedef>
  <function id="fetch::rpc::PackArgs" name="PackArgs">
    <brief> This is the no-argument packer.</brief>
    <doc>This function covers the case where no arguments are given. The
serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::rpc::PackArgs::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::rpc#fetch::rpc::serializer_type" />
    </argument>
  </function>
  <function id="fetch::rpc::PackCall" name="PackCall">
    <brief> This function is the no-argument packer.</brief>
    <doc>This function covers the case where no arguments are given. The
serializer is is always left at position 0.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fetch::rpc::PackCall::serializer" name="serializer">
      <doc>is the serializer to which the arguments will be packed.</doc>
      <type name="serializer_type" qualifier=" &amp;" ref="fetch::rpc#fetch::rpc::serializer_type" />
    </argument>
    <argument id="fetch::rpc::PackCall::protocol" name="protocol">
      <doc>is the protocol the call belongs to.</doc>
      <type name="protocol_handler_type" qualifier=" const &amp;" ref="fetch::rpc#fetch::rpc::protocol_handler_type" />
    </argument>
    <argument id="fetch::rpc::PackCall::function" name="function">
      <doc>is the function that is being called.</doc>
      <type name="function_handler_type" qualifier=" const &amp;" ref="fetch::rpc#fetch::rpc::function_handler_type" />
    </argument>
  </function>
</namespace>
